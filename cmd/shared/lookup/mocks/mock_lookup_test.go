// Code generated by MockGen. DO NOT EDIT.
// Source: lookup/lookup.go

// Package mocks is a generated GoMock package.
package mocks

import (
	reflect "reflect"
	"testing"

	gomock "go.uber.org/mock/gomock"
)

func TestNewMockTeamsLookup(t *testing.T) {
	type args struct {
		ctrl *gomock.Controller
	}
	tests := []struct {
		name string
		args args
		want *MockTeamsLookup
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := NewMockTeamsLookup(tt.args.ctrl); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("NewMockTeamsLookup() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMockTeamsLookup_EXPECT(t *testing.T) {
	tests := []struct {
		name string
		m    *MockTeamsLookup
		want *MockTeamsLookupMockRecorder
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.m.EXPECT(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("MockTeamsLookup.EXPECT() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMockTeamsLookup_ChannelNameFromID(t *testing.T) {
	type args struct {
		teamID    string
		channelID string
	}
	tests := []struct {
		name    string
		m       *MockTeamsLookup
		args    args
		want    string
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := tt.m.ChannelNameFromID(tt.args.teamID, tt.args.channelID)
			if (err != nil) != tt.wantErr {
				t.Fatalf("MockTeamsLookup.ChannelNameFromID() error = %v, wantErr %v", err, tt.wantErr)
			}
			if tt.wantErr {
				return
			}
			if got != tt.want {
				t.Errorf("MockTeamsLookup.ChannelNameFromID() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMockTeamsLookupMockRecorder_ChannelNameFromID(t *testing.T) {
	type args struct {
		teamID    interface{}
		channelID interface{}
	}
	tests := []struct {
		name string
		mr   *MockTeamsLookupMockRecorder
		args args
		want *gomock.Call
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.mr.ChannelNameFromID(tt.args.teamID, tt.args.channelID); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("MockTeamsLookupMockRecorder.ChannelNameFromID() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMockTeamsLookup_TeamNameFromID(t *testing.T) {
	type args struct {
		teamID string
	}
	tests := []struct {
		name    string
		m       *MockTeamsLookup
		args    args
		want    string
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := tt.m.TeamNameFromID(tt.args.teamID)
			if (err != nil) != tt.wantErr {
				t.Fatalf("MockTeamsLookup.TeamNameFromID() error = %v, wantErr %v", err, tt.wantErr)
			}
			if tt.wantErr {
				return
			}
			if got != tt.want {
				t.Errorf("MockTeamsLookup.TeamNameFromID() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMockTeamsLookupMockRecorder_TeamNameFromID(t *testing.T) {
	type args struct {
		teamID interface{}
	}
	tests := []struct {
		name string
		mr   *MockTeamsLookupMockRecorder
		args args
		want *gomock.Call
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.mr.TeamNameFromID(tt.args.teamID); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("MockTeamsLookupMockRecorder.TeamNameFromID() = %v, want %v", got, tt.want)
			}
		})
	}
}
